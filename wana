#!/bin/sh

export POSIXLY_CORRECT=yes
set +o | grep "posix" | {
    while read set_cmd; do
        eval set -o "$( echo "$set_cmd" | cut -s -d ' ' -f 3 )" "2>/dev/null"
    done
}

abort()
{
    exit 1 # make sure we exit with exit code on abort
}
trap 'abort' 0

set -e
#set -x

EOL="$( printf '\n ' )" && EOL="${EOL% }"
SCRIPT_NAME=`basename "$0"`
EXIT_CODE_UNKNOWN_COMMAND=1
EXIT_CODE_INVALID_LOG_FILE=2

error_exit() {
    exit_code="$1"
    shift
    echo "$SCRIPT_NAME:" "$@" 1>&2
    exit "$exit_code"
}

error_warn() {
    echo "$SCRIPT_NAME:" "$@" 1>&2
}

F_AFTER=""
F_BEFORE=""
F_IP=""
F_URI=""


ARG_END=n
OTHERS=""
while [ $# -gt 0 ]; do
    if [ "$ARG_END" = y ]; then
        OTHERS="${OTHERS} $1"
        shift # arg
    else
        case "$1" in
            -a) # DATETIME – after = jsou uvažovány pouze záznamy PO tomto datu (bez tohoto data). DATETIME je formátu YYYY-MM-DD HH:MM:SS
                F_AFTER="$2"
                if [ -z "$F_AFTER" ]; then
                    error_exit "$EXIT_CODE_UNKNOWN_COMMAND" "Invalid date (for -a): Empty argument"
                fi
                shift 2 # arg + val
            ;;
            -b) # DATETIME – before, jsou uvažovány pouze záznamy PŘED tímto datem (bez tohodo data)
                F_BEFORE="$2"
                if [ -z "$F_BEFORE" ]; then
                    error_exit "$EXIT_CODE_UNKNOWN_COMMAND" "Invalid date (for -b): Empty argument"
                fi
                shift 2 # arg + val
            ;;
            -ip) # IPADDR – jsou uvažovány pouze záznamy odpovídající požadavkům ze zdrojové adresy IPADDR. Formát IPADDR odpovídá IPv4 nebo IPv6.
                F_IP="$2"
                if [ -z "$F_IP" ]; then
                    error_exit "$EXIT_CODE_UNKNOWN_COMMAND" "Invalid ip (for -ip): Empty argument"
                fi
                shift 2 # arg + val
            ;;
            -uri) # URI – jsou uvažovány pouze záznamy týkající se dotazů na konkrétní webovou stránku. URI je základní regulární výraz.
                F_URI="$2"
                if [ -z "$F_URI" ]; then
                    error_exit "$EXIT_CODE_UNKNOWN_COMMAND" "Invalid uri (for -uri): Empty argument"
                fi
                shift 2 # arg + val
            ;;
            --) # end of arguments
                ARG_END=y
                shift # arg
            ;;
            *)
                OTHERS="${OTHERS} $1"
                shift # arg
            ;;
        esac
    fi
done
set -- ${OTHERS}

CMD=""
FILES=""

for arg in $@; do # TODO: How can we distinguish between command and log file?!
    if [ -e "$arg" ]; then
        FILES="${FILES} $arg"
        continue
    fi
    case "$arg" in
        *.log | *.gz)
            if [ ! -e "$arg" ]; then
                error_exit "$EXIT_CODE_INVALID_LOG_FILE" "Invalid log file: $arg"
            fi
            FILES="${FILES} $arg"
        ;;
        *)
            if [ -z "$CMD" ]; then
                if [ -z "$arg" ]; then
                    error_exit "$EXIT_CODE_UNKNOWN_COMMAND" "Unknown command: Empty argument"
                fi
                CMD="$arg"
            else
                error_exit "$EXIT_CODE_UNKNOWN_COMMAND" "Failed to parse arguments: Only single command supported"
            fi
        ;;
    esac
done

# Log line format:
I_LOG_IP=1           # $1       =  1      -> IP
I_LOG_IDENTITY=2     # $2       =  2      -> Identity
I_LOG_USER_ID=3      # $3       =  3      -> User ID
I_LOG_DATE_TIME=4    # $4       = [4]     -> Date and time
I_LOG_HTTP_METHOD=5
I_LOG_HTTP_URI=6
I_LOG_HTTP_VERSION=7 # $5 $6 $7 = "5 6 7" -> Http method + uri + version
I_LOG_HTTP_STATUS=8  # $8       =  8      -> Http status
I_LOG_SENT_SIZE=9    # $9       =  9      -> Sent data size
I_LOG_REFERER=10     # $10      = "10"    -> Referer?
I_LOG_USER_AGENT=11  # $11      = "11"    -> User agent

parse_log_line() {
    # Regex in posix was unusable...
    # So parsing will be done manually.
    line="$1"
    
    echo "$( echo "$line" | cut -d ' ' -f 1 )" # ip
    echo "$( echo "$line" | cut -d ' ' -f 2 )" # identity
    echo "$( echo "$line" | cut -d ' ' -f 3 )" # userId
    
    line="$( echo "$line" | cut -d ' ' -f 4- | cut -d '[' -f 2- )"
    
    echo "$( echo "$line" | cut -d ']' -f 1 )" # dateTime
    
    line="$( echo "$line" | cut -d ']' -f 2- | cut -d ' ' -f 2- | cut -d '"' -f 2- )"
    
    httpInfo="$( echo "$line" | cut -d '"' -f 1 )"
    if [ -z "$( echo "$httpInfo" | cut -s -d ' ' -f 1- )" ]; then
        echo "-" # httpMethod
        echo "-" # httpUri
        echo "-" # httpVersion
        # httpInfoGarbage="""
    else
        echo "$( echo "$httpInfo" | cut -d ' ' -f 1 )" # httpMethod
        echo "$( echo "$httpInfo" | cut -d ' ' -f 2 )" # httpUri
        echo "$( echo "$httpInfo" | cut -d ' ' -f 3 )" # httpVersion
        # httpInfoGarbage="$( echo "$httpInfo" | cut -d ' ' -f 4- )" # httpInfoGarbage
    fi
    
    # line="$( echo "$line" | cut -d '"' -f 2- | cut -d ' ' -f 2- )"
    
    # echo "$( echo "$line" | cut -d ' ' -f 1 )" # httpStatus
    # echo "$( echo "$line" | cut -d ' ' -f 1 )" # sentDataSize
    
    # line="$( echo "$line" | cut -d ' ' -f 3- | cut -d '"' -f 2- )"
    
    # echo "$( echo "$line" | cut -d '"' -f 1 )" # referer
    
    # line="$( echo "$line" | cut -d '"' -f 2- | cut -d ' ' -f 2- | cut -d '"' -f 2- )"
    
    # echo "$( echo "$line" | cut -d '"' -f 1 )" # userAgent
    
    # line="$( echo "$line" | cut -d '"' -f 2- )"
    
    # echo "$line" # garbage
    
    # if [ -n "$line" ]; then
    #     error_warn "Found malformed log line!"
    # fi
}

normalize_date() {
    echo "$( echo "$1" | sed 's/[\/\\.: -]/_/g' )"
}

month_name_to_int() {
    case "$1" in
        Jan) echo "01" ;;
        Feb) echo "02" ;;
        Mar) echo "03" ;;
        Apr) echo "04" ;;
        May) echo "05" ;;
        Jun) echo "06" ;;
        Jul) echo "07" ;;
        Aug) echo "08" ;;
        Sep) echo "09" ;;
        Oct) echo "10" ;;
        Nov) echo "11" ;;
        Dec) echo "12" ;;
        *) echo "00" ;;
    esac
}

normalize_log_date() {
    date=`normalize_date "$1"`
    month_name="$( echo "$date" | cut -s -d '_' -f 2 )"
    printf "%s_%s_%s_%s" \
    "$( echo "$date" | cut -s -d '_' -f 3 )" \
    "$( month_name_to_int "$( echo "$date" | cut -s -d '_' -f 2 )" )" \
    "$( echo "$date" | cut -s -d '_' -f 1 )" \
    "$( echo "$date" | cut -s -d '_' -f 4-6 )"
}

beautify_hour_date() { # YYYY-MM-DD HH:00
    printf "%s-%s-%s %s:%s" \
    "$( echo "$1" | cut -s -d '_' -f 1 )" \
    "$( echo "$1" | cut -s -d '_' -f 2 )" \
    "$( echo "$1" | cut -s -d '_' -f 3 )" \
    "$( echo "$1" | cut -s -d '_' -f 4 )" \
    "00"
}

next_beautify_hour_date() {
    date="$( echo "$1" | sed 's/[ :-]/_/g' )"
    yy="$( echo "$date" | cut -s -d '_' -f 1 )"
    mm="$( echo "$date" | cut -s -d '_' -f 2 )"
    dd="$( echo "$date" | cut -s -d '_' -f 3 )"
    hh="$( echo "$date" | cut -s -d '_' -f 4 )"
    
    hh=`expr $hh + 1`
    if [ "$hh" -gt 23 ]; then
        return
    fi
    
    hh=$(printf "%02d" "$hh")
    printf "%s-%s-%s %s:%s" "$yy" "$mm" "$dd" "$hh" "00"
}

add_missing_hour_times() {
    while read current_date_time && [ -z "$current_date_time" ]; do :; done
    echo "$current_date_time"
    
    while read date_time; do # add missing hours from input
        while :; do
            current_date_time=`next_beautify_hour_date "$current_date_time"`
            if [ -z "$current_date_time" ]; then # can't predict next time
                current_date_time="$date_time"
                echo "$current_date_time"
                break
            fi
            
            echo "$current_date_time"
            if [ ! "$current_date_time" \< "$date_time" ]; then
                break
            fi
        done
    done
}

get_hostname() {
    host=`host "$line"`
    if [ $? -ne 0 ]; then
        return 1
    fi
    host="$( echo "$host" | tail -n -1 | awk -F "domain name pointer " '{ print $2 }' )"
    host="${host%.}" # remove tailing dot
    echo "$host"
}

try_get_hostname() {
    get_hostname "$1" || get_hostname "$1" || get_hostname "$1" || echo "$1"
}

map_get_val() {
    echo `eval echo '$'$1`
}

map_set_val() {
    eval "$1='$2'"
}

add_map_values_to_names() {
    map_name="$1"
    map_key_regex="$2"
    
    while read name_line; do # add value before every map name
        if [ -z "$name_line" ]; then
            continue
        fi
        
        name_id="$( echo "$name_line" | sed "$map_key_regex" )"
        name_val=`map_get_val "$map_name$name_id"`
        if [ -z "$name_val" ]; then
            name_val=0
        fi
        printf "%s %s\n" "$name_val" "$name_line"
    done
}

draw_hist() {
    max_name_len="$1"
    total_max_value="$2"
    
    max_val_len="$( printf "%s" "$total_max_value" | wc -m )"
    
    # calculate graph width
    width=$( tput cols 2> /dev/null )
    if [ -z "$width" ]; then
        graph_width=100
    else
        graph_width=`expr "$width" - "$max_name_len" - "$max_val_len" - 5`
        if [ "$graph_width" -lt 15 ]; then
            graph_width=15
        fi
    fi
    
    # draw histogram
    while read val_name_line; do
        if [ -z "$val_name_line" ]; then
            continue
        fi
        
        value="$( echo "$val_name_line" | cut -s -d ' ' -f 1 )"
        name="$( echo "$val_name_line" | cut -s -d ' ' -f 2- )"
        
        printf "%${max_name_len}s (%${max_val_len}s): " "$name" "$value"
        
        i=0
        len=`expr "$value" \* "$graph_width" / "$total_max_value" || true` # true => ignore exit code of expr
        while [ "$i" -lt "$len" ]; do
            printf "#"
            i=`expr "$i" + 1`
        done
        while [ "$i" -lt "$graph_width" ]; do # fill remaining space with spaces (keep consistent line length)
            printf " "
            i=`expr "$i" + 1`
        done
        printf "\n"
    done
}

files_read() {
    if [ -z "${FILES}" ]; then
        cat # read from stdin
    else
        for file in ${FILES}; do
            cat "$file" | {
                case "$file" in
                    *.gz)
                        gzip -d
                    ;;
                    *)
                        cat
                    ;;
                esac
            }
        done
    fi
}

files_filter() {
    while read line; do
        parsed_line=`parse_log_line "$line"`
        
        allow=y
        if [ -n "$F_AFTER" ] || [ -n "$F_BEFORE" ]; then
            dateTime="$( echo "$parsed_line" | sed -n "${I_LOG_DATE_TIME}p" )"
            if [ -z "$dateTime" ] || [ "$dateTime" = "-" ]; then
                allow=n
            else
                dateTime=`normalize_log_date "$dateTime"`
            fi
            
            if [ "$allow" = y ] && [ -n "$F_AFTER" ]; then
                F_AFTER=`normalize_date "$F_AFTER"`
                if [ "$dateTime" \< "$F_AFTER" ] || [ "$dateTime" = "$F_AFTER" ]; then
                    allow=n
                fi
            fi
            if [ "$allow" = y ] && [ -n "$F_BEFORE" ]; then
                F_BEFORE=`normalize_date "$F_BEFORE"`
                if [ "$dateTime" \> "$F_BEFORE" ] || [ "$dateTime" = "$F_BEFORE" ]; then
                    allow=n
                fi
            fi
        fi
        
        if [ "$allow" = y ] && [ -n "$F_IP" ]; then
            ip="$( echo "$parsed_line" | sed -n "${I_LOG_IP}p" )"
            if [ -z "$ip" ] || [ "$ip" = "-" ] || [ "$ip" != "$F_IP" ]; then
                allow=n
            fi
        fi
        
        if [ "$allow" = y ] && [ -n "$F_URI" ]; then
            uri="$( echo "$parsed_line" | sed -n "${I_LOG_HTTP_URI}p" )"
            if [ -z "$uri" ] || [ "$uri" = "-" ] || [ "$uri" != "$F_URI" ]; then
                allow=n
            fi
        fi
        
        if [ "$allow" = y ]; then
            echo "$line"
        fi
    done
}

cmd_list_ip() { # FIXME: Should we print out duplicates?!
    {
        while read line; do
            parsed_line=`parse_log_line "$line"`
            echo "$( echo "$parsed_line" | sed -n "${I_LOG_IP}p" )"
        done
    } | sort -u
}

cmd_list_hosts() { # FIXME: Should we print out duplicates?!
    cmd_list_ip | {
        while read line; do
            echo "$( try_get_hostname "$line" )"
        done
    } | sort -u
}

cmd_list_uri() {
    {
        while read line; do
            parsed_line=`parse_log_line "$line"`
            uri="$( echo "$parsed_line" | sed -n "${I_LOG_HTTP_URI}p" )"
            if [ -z "$uri" ] || [ "$uri" = "-" ]; then
                continue
            fi
            echo "$uri"
        done
    } | sort -u
}

cmd_hist_ip() {
    max_name_len=5
    total_max_value=0
    map_name="ip_map_"
    map_key_regex='s/[.:]/_/g'
    map_names=""
    while read line; do # calculate usage for every ip
        parsed_line=`parse_log_line "$line"`
        name="$( echo "$parsed_line" | sed -n "${I_LOG_IP}p" )"
        name_id="$( echo "$name" | sed "$map_key_regex" )"
        
        name_len="$( printf "%s" "$name" | wc -m )"
        if [ "$name_len" -gt "$max_name_len" ]; then
            max_name_len="$name_len"
        fi
        
        name_val=`map_get_val "$map_name$name_id"`
        if [ -z "$name_val" ]; then
            name_val=0
            map_names="$map_names$name$EOL"
        fi
        
        name_val=`expr "$name_val" + 1`
        if [ "$name_val" -gt "$total_max_value" ]; then
            total_max_value="$name_val"
        fi
        
        map_set_val "$map_name$name_id" "$name_val"
    done
    
    echo "$map_names" | add_map_values_to_names "$map_name" "$map_key_regex" | sort -n -r | draw_hist "$max_name_len" "$total_max_value"
}

cmd_hist_load() {
    max_name_len=16 # YYYY-MM-DD HH:MM
    total_max_value=0
    map_name="time_map_"
    map_key_regex='s/[ :-]/_/g'
    map_names=""
    while read line; do # calculate usage for every hour
        parsed_line=`parse_log_line "$line"`
        name="$( beautify_hour_date "$( normalize_log_date "$( echo "$parsed_line" | sed -n "${I_LOG_DATE_TIME}p" )" )" )"
        name_id="$( echo "$name" | sed "$map_key_regex" )"
        
        name_len="$( printf "%s" "$name" | wc -m )"
        if [ "$name_len" -gt "$max_name_len" ]; then
            max_name_len="$name_len"
        fi
        
        name_val=`map_get_val "$map_name$name_id"`
        if [ -z "$name_val" ]; then
            name_val=0
            map_names="$map_names$name$EOL"
        fi
        
        name_val=`expr "$name_val" + 1`
        if [ "$name_val" -gt "$total_max_value" ]; then
            total_max_value="$name_val"
        fi
        
        map_set_val "$map_name$name_id" "$name_val"
    done
    
    # | add_missing_hour_times # FIXME: should be added!?
    echo "$map_names" | sort | add_map_values_to_names "$map_name" "$map_key_regex" | draw_hist "$max_name_len" "$total_max_value"
}

cmd_basic_print() {
    cat # just print out input
}

files_read | files_filter | {
    case "$CMD" in
        list-ip) # výpis seznamu zdrojových IP adres
            cmd_list_ip
        ;;
        list-hosts) # výpis seznamu zdrojových doménových jmen
            cmd_list_hosts
        ;;
        list-uri) # výpis seznamu cílových zdrojů (URI)
            cmd_list_uri
        ;;
        hist-ip) # výpis histogramu četností dotazů podle zdrojových IP adres
            cmd_hist_ip
        ;;
        hist-load) # výpis histogramu zátěže (tj. počtu dotazů ve jednotlivých časových intervalech)
            cmd_hist_load
        ;;
        "") # no command
            cmd_basic_print
        ;;
        *) # unknown command
            error_exit "$EXIT_CODE_UNKNOWN_COMMAND" "Unknown command: $CMD"
        ;;
    esac
}

trap : 0 # cancel exit trap -> exit with 0
